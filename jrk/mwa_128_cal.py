import aipy as a, numpy as n, os

class AntennaArray(a.pol.AntennaArray):
    def __init__(self, *args, **kwargs):
        a.pol.AntennaArray.__init__(self, *args, **kwargs)
        self.array_params = {}
    def get_ant_params(self, ant_prms={'*':'*'}):
        prms = a.fit.AntennaArray.get_params(self, ant_prms)
        for k in ant_prms:
            top_pos = n.dot(self._eq2zen, self[int(k)].pos)
            if ant_prms[k] == '*':
                prms[k].update({'top_x':top_pos[0], 'top_y':top_pos[1], 'top_z':top_pos[2]})
            else:
                for val in ant_prms[k]:
                    if   val == 'top_x': prms[k]['top_x'] = top_pos[0]
                    elif val == 'top_y': prms[k]['top_y'] = top_pos[1]
                    elif val == 'top_z': prms[k]['top_z'] = top_pos[2]
        return prms
    def set_ant_params(self, prms):
        changed = a.fit.AntennaArray.set_params(self, prms)
        for i, ant in enumerate(self):
            ant_changed = False
            top_pos = n.dot(self._eq2zen, ant.pos)
            try:
                top_pos[0] = prms[str(i)]['top_x']
                ant_changed = True
            except(KeyError): pass
            try:
                top_pos[1] = prms[str(i)]['top_y']
                ant_changed = True
            except(KeyError): pass
            try:
                top_pos[2] = prms[str(i)]['top_z']
                ant_changed = True
            except(KeyError): pass
            if ant_changed: ant.pos = n.dot(n.linalg.inv(self._eq2zen), top_pos)
            changed |= ant_changed
        return changed 
    def get_arr_params(self):
        return self.array_params
    def set_arr_params(self, prms):
        for param in prms:
            self.array_params[param] = prms[param]
            if param == 'dish_size_in_lambda':
                FWHM = 2.35*(0.45/prms[param]) #radians
                self.array_params['obs_duration'] = 60.*FWHM / (15.*a.const.deg)# minutes it takes the sky to drift through beam FWHM
            if param == 'antpos':
                bl_lens = n.sum(n.array(prms[param])**2,axis=1)**.5
        return self.array_params

#===========================ARRAY SPECIFIC PARAMETERS==========================

#Set antenna positions here; for regular arrays like Hera we can use an algorithm; otherwise antpos should just be a list of [x,y,z] coords in light-nanoseconds

antpos_dict = {
11: [-149.785, 265.814, 377.01099],
12: [-95.364998, 270.18799, 377.285],
13: [-88.512001, 266.021, 377.30899],
14: [-78.697998, 258.431, 377.29099],
15: [-86.940002, 248.452, 377.33899],
16: [-102.325, 244.088, 377.258],
17: [-93.346001, 242.27901, 377.26999],
18: [-148.33, 220.271, 377.21399],
21: [-132.939, 282.61099, 377.00201],
22: [-139.867, 275.49799, 377.01801],
23: [-123.667, 284.854, 377.04999],
24: [-92.889, 281.358, 377.254],
25: [-77.834999, 282.83899, 377.25299],
26: [-83.475998, 277.56299, 377.29999],
27: [-76.987999, 272.63699, 377.298],
28: [-176.006, 289.90302, 376.62299],
31: [-23.620001, 201.54601, 376.80499],
32: [-23.802, 222.353, 376.87201],
33: [-40.488998, 235.17, 376.961],
34: [-54.527, 237.51801, 377.12299],
35: [-64.850998, 250.813, 377.23901],
36: [-70.074997, 259.40201, 377.26599],
37: [-60.056999, 263.67599, 377.17999],
38: [-50.675999, 264.54599, 377.10001],
41: [-67.989998, 271.103, 377.23599],
42: [-60.057999, 271.905, 377.20401],
43: [-70.885002, 278.81799, 377.25201],
44: [-45.540001, 273.245, 377.06601],
45: [-53.155998, 276.26801, 377.09],
46: [-22.659, 263.694, 376.948],
47: [-55.097, 284.285, 377.181],
48: [-14.9, 273.87, 376.91],
51: [-55.560001, 124.801, 376.80301],
52: [177.467, -43.376999, 375.005],
53: [-21.709999, 77.004997, 376.35101],
54: [91.808998, -80.565002, 375.76001],
55: [153.7, -259.92899, 376.47601],
56: [-67.582001, -22.361, 376.17499],
57: [-118.037, -39.873001, 376.05399],
58: [-87.515999, 125.197, 377.03101],
61: [-105.281, 217.17999, 377.255],
62: [-98.529999, 230.162, 377.26001],
63: [-81.845001, 229.33701, 377.26999],
64: [-79.541, 238.12801, 377.26999],
65: [-75.120003, 247.002, 377.255],
66: [-71.016998, 235.929, 377.23901],
67: [-62.567001, 228.987, 377.20999],
68: [-50.691002, 221.88499, 377.078],
71: [-195.98, 189.795, 377.16101],
72: [-198.194, 95.150002, 377.02399],
73: [-284.457, -196.181, 374.901],
74: [-388.15201, -44.021999, 375.37201],
75: [-452.686, -15.933, 375.11099],
76: [-468.81699, 185.187, 374.75201],
77: [-364.52399, 183.09801, 375.73901],
78: [-369.608, 266.48401, 375.23999],
81: [-160.465, 573.20697, 374.77301],
82: [-128.04601, 350.49399, 376.57001],
83: [-69.771004, 294.03101, 377.19199],
84: [-78.731003, 297.259, 377.19601],
85: [-103.941, 300.914, 377.04999],
86: [-100.172, 288.896, 377.15701],
87: [-395.452, 371.15201, 374.51501],
88: [-263.547, 389.27399, 375.32199],
91: [326.14099, 203.608, 373.94501],
92: [173.425, 193.595, 375.03201],
93: [-2.5150001, 292.841, 376.892],
94: [-46.554001, 287.46899, 377.11499],
95: [-56.140999, 295.922, 377.15601],
96: [-33.705002, 351.048, 376.97601],
97: [50.126999, 536.159, 376.181],
98: [84.879997, 519.14099, 376.314],
101: [-518.04602, 632.50299, 372.604],
102: [-489.94299, 604.56799, 372.90701],
103: [-575.55701, 415.008, 373.37399],
104: [-585.67499, -101.53, 375.21201],
105: [-653.46698, 142.255, 374.46201],
106: [-685.02698, 212.168, 374.23599],
107: [-1079.6, 87.017998, 377.009],
108: [-1026.0699, 574.52698, 374.039],
111: [-333.758, 1660.73, 371.06799],
112: [-227.151, 898.12903, 373.694],
113: [-173.717, 781.638, 374.21701],
114: [-256.952, 892.005, 373.492],
115: [-195.01801, 762.89301, 374.09299],
116: [-249.647, 731.70898, 373.797],
117: [-300.69601, 704.32599, 373.51401],
118: [-889.47101, 1088.14, 370.38101],
121: [716.39301, 1405.26, 374.60199],
122: [288.06601, 618.26501, 375.134],
123: [238.31, 768.41302, 375.80499],
124: [227.87801, 819.724, 375.74799],
125: [61.443001, 815.255, 376.00101],
126: [-58.874001, 810.53003, 375.17001],
127: [35.223999, 950.242, 376.27499],
128: [1.015, 1412.36, 373.68201],
131: [839.94299, 990.22699, 372.69601],
132: [1177.29, 858.63202, 372.12201],
133: [1313.61, 553.37201, 370.354],
134: [556.12201, 244.485, 372.284],
135: [571.54102, 359.20999, 372.509],
136: [488.85699, 424.98001, 372.96701],
137: [528.59802, 539.19397, 372.789],
138: [381.069, 652.86401, 374.25101],
141: [1100.9399, 151.75999, 369.065],
142: [1201.13, -443.25, 368.328],
143: [498.629, -264.59399, 373.22],
144: [301.19299, -48.952, 374.61801],
145: [370.64801, -38.415001, 374.34],
146: [544.32397, -91.152, 372.81201],
147: [506.793, -3.2160001, 372.80301],
148: [523.72699, 75.494003, 372.61301],
151: [653.77399, -1037.75, 371.07101],
152: [442.98999, -835.30603, 372.25101],
153: [-58.800999, -505.332, 372.91299],
154: [37.064999, -405.04999, 374.034],
155: [232.842, -357.89099, 375.26199],
156: [257.98401, -366.453, 375.22101],
157: [325.68799, -318.508, 375.02899],
158: [326.10101, -306.30701, 375.12799],
161: [-412.457, -409.06, 373.96899],
162: [-141.89799, -420.26099, 373.50299],
163: [-480.26999, -817.32397, 375.72],
164: [-575.53302, -863.78198, 375.522],
165: [-674.021, -638.87097, 375.34],
166: [-631.40302, -245.10699, 375.54401],
167: [-633.237, -169.362, 375.616],
168: [-568.53998, -257.66, 375.246]
}

antpos = []
for pos in antpos_dict.values():
    antpos.append(n.array(pos)*100./a.const.len_ns)

#Set other array parameters here
prms = {
    'name': os.path.basename(__file__)[:-3], #remove .py from filename
#    'loc': ('38:25:59.24',  '-79:51:02.1'), # Green Bank, WV
    'loc': ('-26:42:11.916', '116:40:15.06'), # MWA,  (GPS)
    'antpos': antpos,
    'beam': a.fit.Beam2DGaussian,
    'dish_size_in_lambda': 2.32, #in units of wavelengths at 150 MHz = 2 meters; this will also define the observation duration
    'Trx': 1e5 #receiver temp in mK
}

#=======================END ARRAY SPECIFIC PARAMETERS==========================

def get_aa(freqs):
    '''Return the AntennaArray to be used for simulation.'''
    location = prms['loc']
    antennas = []
    nants = len(prms['antpos'])
    for i in range(nants):
        beam = prms['beam'](freqs, xwidth=(0.45/prms['dish_size_in_lambda']), ywidth=(0.45/prms['dish_size_in_lambda'])) #as it stands, the size of the beam as defined here is not actually used anywhere in this package, but is a necessary parameter for the aipy Beam2DGaussian object
        antennas.append(a.fit.Antenna(0, 0, 0, beam))
    aa = AntennaArray(prms['loc'], antennas)
    p = {}
    for i in range(nants):
        top_pos = prms['antpos'][i]
        p[str(i)] = {'top_x':top_pos[0], 'top_y':top_pos[1], 'top_z':top_pos[2]}
    aa.set_ant_params(p)
    aa.set_arr_params(prms) 
    return aa

def get_catalog(*args, **kwargs): return a.src.get_catalog(*args, **kwargs)
